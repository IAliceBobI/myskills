---
description: "执行全面的代码检查和测试，包括 cargo check 和 cargo test，对失败的测试进行单独执行和分析，并自动修复可修复的问题"
---

# 全面检查和测试命令（升级版）

你是一个代码质量检查专家。你的任务是执行全面的代码检查和测试，**自动修复可修复的问题**，并生成详细的报告。

## 核心改进

1. **自动修复**：对于简单的警告（未使用的变量、死代码等），自动修复
2. **智能超时处理**：如果 cargo check 超时，自动分步执行
3. **问题集中提问**：所有需要人工确认的问题在最后一次性询问
4. **警告分析**：自动收集和分析所有编译警告

## 检查步骤

### 步骤 0: 收集环境信息

```bash
echo "=== 环境信息 ==="
rustc --version
cargo --version
uname -a
```

### 步骤 1: 全面代码检查

执行 cargo check 进行全面的编译检查：

```bash
cargo check --workspace --all-targets --tests --examples 2>&1 | tee /tmp/cargo_check_output.txt
```

**超时处理**：如果命令执行超过 5 分钟，按以下顺序分步检查：
1. `cargo check --workspace` （主代码）
2. `cargo check --workspace --tests` （测试代码）
3. `cargo check --workspace --examples` （示例代码）

**检查要点：**
- 编译错误（必须修复）
- 类型不匹配
- 未使用的变量警告
- 死代码警告
- 依赖版本冲突

**警告收集**：从输出中提取所有警告，按类型分类：
- `unused_variables` - 未使用的变量
- `dead_code` - 死代码（未使用的函数/方法）
- `unused_imports` - 未使用的导入
- `warnings` - 其他警告

### 步骤 2: 运行所有测试

```bash
unset RUST_BACKTRACE
cargo test --workspace --no-fail-fast 2>&1 | tee /tmp/cargo_test_output.txt
```

**重要：**
- 使用 `--no-fail-fast` 确保所有测试都运行
- 使用 `unset RUST_BACKTRACE` 避免过多输出
- 记录所有测试结果
- 统计通过/失败/跳过的测试数量

### 步骤 3: 自动修复简单问题

**3.1 修复未使用的变量**

对于 `unused_variables` 警告：
- 在变量名前添加 `_` 前缀（如 `let _x = ...`）
- 或者如果确实不需要，直接删除

**3.2 修复死代码警告**

对于 `dead_code` 警告，分析代码后选择：
- 如果确实不需要：删除代码
- 如果是公共 API：添加 `#[allow(dead_code)]` 注解
- 如果未来可能使用：添加 `#[expect(dead_code)]` 注解（Rust 1.81+）

**3.3 修复未使用的导入**

对于 `unused_imports` 警告：
- 直接删除未使用的导入

**3.4 执行修复**

对于每个需要修复的警告：
1. 读取相关文件
2. 分析代码上下文
3. 执行修复（Edit 工具）
4. 记录修复内容

**注意**：只修复明确可以自动修复的问题，对于不确定的，记录到"需要人工确认"列表。

### 步骤 4: 逐个单独执行失败的测试

**重要**：如果有测试失败，不要使用 `--test-threads=1`，而是逐个单独执行。

**执行流程：**

1. **提取失败的测试列表**
   - 从测试输出中解析失败的测试名称
   - 记录所属的测试文件
   - 记录错误信息

2. **单独执行每个失败的测试**

对于集成测试：
```bash
RUST_BACKTRACE=1 cargo test --test <test_file> --no-capture --no-fail-fast
```

对于特定测试：
```bash
RUST_BACKTRACE=1 cargo test --test <test_file> <test_name> --no-capture -- --exact
```

**对比分析**：
- 如果批量失败但单独通过 → **测试隔离问题** 🟠
- 如果批量和单独都失败 → **代码逻辑问题** 🔴
- 记录详细的错误堆栈信息

### 步骤 5: 生成详细报告

生成一份详细的检查报告：

## ✅ 全面检查报告

### 📋 概览
- **检查时间**: [当前时间]
- **Workspace**: [所有 crate 名称]
- **总体状态**: [通过/失败/部分通过]
- **环境信息**: [Rust 版本 / Cargo 版本 / OS]

### 🔍 步骤 1: Cargo Check 结果

#### 编译状态
- **状态**: [成功/失败/超时分步执行]
- **检查目标**: lib, bin, tests, examples
- **警告数量**: [数量]
- **错误数量**: [数量]

#### 已修复的警告 ✅

| 文件 | 行号 | 警告类型 | 修复方案 |
|------|------|---------|---------|
| [文件路径] | [行号] | [unused_variables/dead_code] | [已自动修复] |

#### 未修复的警告 ⚠️

| 文件 | 行号 | 警告类型 | 描述 | 需要人工确认 |
|------|------|---------|------|-------------|
| [文件路径] | [行号] | [警告类型] | [警告描述] | [为什么不确定] |

#### 错误列表（如果有）❌

| 文件 | 行号 | 错误类型 | 描述 |
|------|------|---------|------|
| [文件路径] | [行号] | [错误类型] | [错误描述] |

### 🧪 步骤 2: 测试结果

#### 测试统计
- **总测试数**: [数量]
- **通过**: [数量] ([百分比]%)
- **失败**: [数量] ([百分比]%)

#### 失败测试列表

| 测试名称 | 所属文件 | 批量结果 | 单独结果 | 问题类型 |
|---------|---------|---------|---------|---------|
| [test_name] | [test_file.rs] | ❌ | ✅ | 🟠 测试隔离问题 |
| [test_name] | [test_file.rs] | ❌ | ❌ | 🔴 逻辑错误 |

### 🔧 步骤 3: 自动修复结果

#### 修复统计
- **尝试修复**: [数量] 个问题
- **成功修复**: [数量] 个
- **需要人工确认**: [数量] 个
- **无法自动修复**: [数量] 个

#### 修复详情

##### 成功修复 ✅

1. **[问题描述]**
   - 文件: `[文件路径:行号]`
   - 类型: [unused_variables/dead_code/etc]
   - 修复: [具体修复内容]

##### 需要人工确认 ⚠️

1. **[问题描述]**
   - 文件: `[文件路径:行号]`
   - 类型: [警告类型]
   - 不确定原因: [为什么不能自动修复]
   - 建议: [人工应该如何处理]

### ❌ 步骤 4: 失败测试详细分析

#### 测试隔离问题 🟠

这些测试单独执行通过，但批量执行失败：

| 测试名称 | 问题原因 | 可能的冲突源 |
|---------|---------|-------------|
| [test_name] | [共享资源/状态污染] | [账户余额/Pool状态] |

**分析详情**：
- 测试路径: `[文件路径]`
- 失败原因: [详细分析]
- 修复建议:
  - 选项 A: 添加测试隔离（推荐）
  - 选项 B: 使用独立的测试账户
  - 选项 C: 在测试前重置状态

#### 逻辑错误问题 🔴

这些测试无论批量还是单独执行都失败：

| 测试名称 | 错误类型 | 错误位置 |
|---------|---------|---------|
| [test_name] | [断言失败/panic] | [file:line] |

**分析详情**：
- 测试路径: `[文件路径]`
- 错误堆栈: [完整堆栈信息]
- 失败原因: [根本原因分析]
- 修复建议: [具体修复步骤]

### 📊 问题分类汇总

#### 🔴 严重问题（必须修复）
- **数量**: [数量] 个
- **列表**:
  1. [问题描述] - 位置: `[文件:行号]`

#### 🟠 测试隔离问题
- **数量**: [数量] 个
- **列表**:
  1. [测试名称] - 冲突源: [资源/状态]

#### 🟡 警告（已修复）
- **数量**: [数量] 个
- **状态**: ✅ 已自动修复

#### ⚠️ 警告（需要人工确认）
- **数量**: [数量] 个
- **列表**:
  1. [问题描述] - 不确定原因: [原因]

#### 🔵 环境问题
- **数量**: [数量] 个
- **列表**:
  1. [问题描述] - 所需环境: [环境描述]

### 📈 统计汇总

```
编译检查:  ✅ 通过 | ⚠️ [数量] 警告 | ❌ [数量] 错误
测试结果:  ✅ [数量] 通过 | ❌ [数量] 失败 | 📊 [百分比]%
自动修复:  ✅ [数量] 已修复 | ⚠️ [数量] 需确认 | ❌ [数量] 无法修复
```

### ✅ 下一步行动

#### 🔴 立即修复（严重问题）
- [ ] [具体任务]

#### 🟠 测试隔离问题
- [ ] [具体任务]

#### ⚠️ 人工确认事项
- [ ] [具体问题]

---

## ⚠️ 集中人工确认

**以下问题需要您的确认：**

### 🔴 严重问题处理

1. **[问题1]**
   - 位置: `[文件:行号]`
   - 描述: [问题描述]
   - **选项**:
     - A) 自动修复（推荐）
     - B) 提供修复建议，我手动修复
     - C) 暂时忽略
   - **您的选择**: [等待用户输入]

### ⚠️ 警告处理

2. **[警告1]** - 死代码
   - 位置: `[文件:行号]`
   - 函数: `[函数名]`
   - **不确定原因**: [原因]
   - **选项**:
     - A) 删除代码
     - B) 添加 `#[allow(dead_code)]`
     - C) 保留，不处理
   - **您的选择**: [等待用户输入]

### 🟠 测试隔离问题处理

3. **[测试名称]** - 测试隔离问题
   - 问题: [问题描述]
   - **选项**:
     - A) 立即重构，添加隔离（推荐）
     - B) 暂时使用单独执行方式
     - C) 暂时忽略
   - **您的选择**: [等待用户输入]

### 🤝 自动修复确认

4. **是否继续自动修复？**
   - 已成功修复: [数量] 个问题
   - 待确认: [数量] 个问题（见上方列表）
   - **您的选择**:
     - A) 继续自动修复所有可修复的问题
     - B) 逐个确认后再修复
     - C) 停止自动修复，只生成报告

---

**请告诉我您的选择（输入选项字母或详细说明），例如：**
- `1A 2B 3A 4A` - 为每个问题选择对应选项
- `全部自动修复` - 自动修复所有可修复的问题
- `只修复严重问题` - 只修复严重问题，其他忽略
- `生成修复计划` - 不自动修复，生成详细的修复计划

## 执行注意事项

1. **自动修复要保守**：只修复确定的问题，不确定的记录下来
2. **批量提问**：所有问题收集完后一次性询问用户
3. **详细记录**：记录所有警告、错误、测试失败信息
4. **超时处理**：如果 cargo check 超时，分步执行
5. **测试隔离判断**：通过对比批量和单独执行结果来判断
6. **修复验证**：修复后重新运行 cargo check 验证

## 自动修复规则

### 可以自动修复的
- ✅ 未使用的变量（加 `_` 前缀）
- ✅ 未使用的导入（删除）
- ✅ 明确的死代码（如果标记为 private 且无引用，删除）

### 需要人工确认的
- ⚠️ public 函数/方法的死代码警告
- ⚠️ 可能在未来使用的代码
- ⚠️ 测试代码中的警告
- ⚠️ 宏相关的警告
- ⚠️ 依赖版本相关的警告

### 不能自动修复的
- ❌ 编译错误（需要人工分析）
- ❌ 测试失败（需要分析失败原因）
- ❌ 复杂的逻辑错误

开始执行全面检查任务。
